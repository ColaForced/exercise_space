线程池大概实现思路:
    
    1. 需求描述：
        - 加入有很多个数据需要相同的处理方式，比如，食堂排队打饭，有很多学生和少量工作人员。 
        - 抽象一下 >> 不同函数参数：菜名； 相同函数处理接口：盛菜；
        - 工作流程 >> 创建线程（呼叫工作人员）--传入参数（报菜名）--执行线程（打菜）

    2. 线程池的必要性
        - 请一个工作人员，打菜，流程结束后辞退该工作人员
        - 线程的创建和销毁造成极大的浪费，除非所有任务都完成了。
        - 需要一个线程池的思维， 工作人员不断响应打菜任务，再配上一个领导来管理工人的创建销毁。
    
    3. 线程池线程关系：
        - worker线程彼此 互斥 访问任务队列， 需一个互斥锁
        - manager，worker 实际是生产者消费者模型，考虑到需要精确数量来控制线程，使用两个条件变量。


    4. 定义基本的数据结构
        - 任务： 用结构体表示，结构体包含一个函数指针和函数参数
        - 任务队列： 环形任务数组表示
        - 其他参数： 任务最大容量，实际任务数，队首任务索引，队尾任务索引

        - 工人： 用线程数组表示 pthread_t *workers
        - 管理： 一个线程变量表示 pthread_t manger
        - 其他参数： 最大，小工作人数， 当前存活工人总数， 当前忙碌工人数， 需要清退工人数量

        -是否需要销毁线程池标志位
    
    5. 功能设计：
        + 公共接口：
            - 创建线程池
            - 销毁线程池
            - 给线程池添加任务
        + 内部接口：
            - 工人:不断读取任务队列，执行任务
            - 管理者：管理工人线程的创建和销毁
    
    6. 存在问题：
        + 测试发现：有时会出现 Segmentation fault (core dumped)， 怎么调试？
            - gdb调试发现[https://www.cnblogs.com/kuliuheng/p/11698378.html]：
                Core was generated by `./a.out'.
                Program terminated with signal SIGSEGV, Segmentation fault.
                #0  0x0000000000401418 in thread_exit (pool=0x1131010) at thread_pool.c:250
                250	        if (pool->workers[i] == tid)
                [Current thread is 1 (Thread 0x7f318ffff700 (LWP 6623))]
                (gdb) bt
                #0  0x0000000000401418 in thread_exit (pool=0x1131010) at thread_pool.c:250
                #1  0x00000000004010d9 in worker (arg=0x1131010) at thread_pool.c:169
                #2  0x00007f31965c86ba in start_thread (arg=0x7f318ffff700)
                    at pthread_create.c:333
                #3  0x00007f31962fe51d in clone ()
                    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
            
            - 看上去出错在 thread_exit
            - 实际上问题在
                if(pool->workers)
                {
                    free(pool->workers);
                    pool->workers = NULL;
                }
            - 在调用thread_pool_destory销毁线程池时， 将wokers指向NULL，则在子线程调用pthread，if (pool->workers[i] == tid)出现指针非法错误。


